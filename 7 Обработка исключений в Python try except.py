
                       """"Как обрабатывать исключения в Python (try except)
                       
            В Python исключения обрабатываются с помощью блоков try/except. Для этого операция,
            которая может вызвать исключение, помещается внутрь блока try. А код, который должен
             быть выполнен при возникновении ошибки, находится внутри except.""""

# Например, вот как можно обработать ошибку деления на ноль:

try:
    a = 7 / 0
except:
    print('Ошибка! Деление на 0')

# Здесь в блоке try находится код
# a = 7 / 0#  — при попытке его выполнить возникнет исключение и выполнится код в блоке
# except (то есть будет выведено сообщение "Ошибка! Деление на 0"). После этого программа
# продолжит свое выполнение. PEP 8 рекомендует, по возможности, указывать конкретный тип
# исключения после ключевого слова except (чтобы перехватывать и обрабатывать конкретные исключения):

try:
    a = 7 / 0
except ZeroDivisionError:
    print('Ошибка! Деление на 0')

# Однако если вы хотите перехватывать все исключения, которые сигнализируют
# об ошибках программы, используйте тип исключения Exception:

try:
    a = 7 / 0
except Exception:
    print('Любая ошибка!')


                           """As — сохраняет ошибку в переменную
                        
            Перехваченная ошибка представляет собой объект класса, унаследованного от "BaseException".
            С помощью ключевого слова as можно записать этот объект в переменную, чтобы обратиться к 
            нему внутри блока except:"""

try:
    file = open('ok123.txt', 'r')
except FileNotFoundError as e:
    print(e)

# > [Errno 2] No such file or directory: 'ok123.txt'
# В примере выше мы обращаемся к объекту класса "FileNotFoundError"
# (при выводе на экран через print отобразится строка с полным описанием ошибки).
# У каждого объекта есть поля, к которым можно обращаться (например если нужно
# логировать ошибку в собственном формате):

import datetime

now = datetime.datetime.now().strftime("%d-%m-%Y %H:%M:%S")

try:
    file = open('ok123.txt', 'r')
except FileNotFoundError as e:
    print(f"{now} [FileNotFoundError]: {e.strerror}, filename: {e.filename}")

#-----> 20-11-2021 18:42:01 [FileNotFoundError]: No such file or directory, filename: ok123.txt


                                    """Finally — выполняется всегда
                                    
            При обработке исключений можно после блока try использовать блок finally. Он похож на блок 
            except, но команды, написанные внутри него, выполняются обязательно. Если в блоке 
            try не возникнет исключения, то блок finally выполнится так же, как и при наличии ошибки, 
            и программа возобновит свою работу."""

file = open('ok.txt', 'r')

try:
    lines = file.readlines()
    print(lines[5])
finally:
    file.close()
    if file.closed:
        print("файл закрыт!")

# -------> файл закрыт!
# -------> Traceback (most recent call last):
# ------->    File "test.py", line 5, in <module>
# ------->      print(lines[5])
# ------->  IndexError: list index out of range

# Даже после исключения "IndexError", сработал код в секции finally, который закрыл файл.


                """Else — выполняется когда исключение не было вызвано
                
        Иногда нужно выполнить определенные действия, когда код внутри блока try не вызвал исключения. 
        Для этого используется блок else."""

# Допустим нужно вывести результат деления двух чисел и
# обработать исключения в случае попытки деления на ноль:

b = int(input('b = '))
c = int(input('c = '))
try:
    a = b / c
except ZeroDivisionError:
    print('Ошибка! Деление на 0')
else:
    print(f"a = {a}")

# -------> b = 10
# -------> c = 1
# -------> a = 10.0
# В этом случае, если пользователь присвоит переменной "с" ноль,
# то появится исключение и будет выведено сообщение "'Ошибка! Деление на 0'",
# а код внутри блока else выполняться не будет. Если ошибки не будет,
# то на экране появятся результаты деления.

                                    """Несколько блоков except
                                    
            В программе может возникнуть несколько исключений, например:
            Ошибка преобразования введенных значений к типу float ("ValueError");
            Деление на ноль ("ZeroDivisionError").В Python, чтобы по-разному
             обрабатывать разные типы ошибок, создают несколько блоков except:"""

try:
    b = float(input('b = '))
    c = float(input('c = '))
    a = b / c
except ZeroDivisionError:
    print('Ошибка! Деление на 0')
except ValueError:
    print('Число введено неверно')
else:
    print(f"a = {a}")

# > b = 10
# > c = 0
# > Ошибка! Деление на 0
#
# > b = 10
# > c = питон
# > Число введено неверно
# Теперь для разных типов ошибок есть свой обработчик.


                        """Несколько типов исключений в одном блоке except
                        
            Можно также обрабатывать в одном блоке except сразу несколько исключений. 
            Для этого они записываются в круглых скобках, через запятую сразу после ключевого слова 
            except. Чтобы обработать сообщения "ZeroDivisionError" и "ValueError" в одном блоке 
            записываем их следующим образом:"""
try:
    b = float(input('b = '))
    c = float(input('c = '))
    a = b / c
except (ZeroDivisionError, ValueError) as er:
    print(er)
else:
    print('a = ', a)

# При этом переменной er присваивается объект того исключения, которое было вызвано.
# В результате на экран выводятся сведения о конкретной ошибке.

                            """Raise — самостоятельный вызов исключений
                            
        Исключения можно генерировать самостоятельно — для этого нужно запустить оператор raise."""


min = 100
if min > 10:
    raise Exception('min must be less than 10')

# > Traceback (most recent call last):
# >  File "test.py", line 3, in <module>
# >    raise Exception('min value must be less than 10')
# > Exception: min must be less than 10
# Перехватываются такие сообщения точно так же, как и остальные:

min = 100

try:
    if min > 10:
        raise Exception('min must be less than 10')
except Exception:
    print('Моя ошибка')

# > Моя ошибка


# Кроме того, ошибку можно обработать в блоке except и пробросить дальше (вверх по стеку) с помощью raise:

min = 100

try:
    if min > 10:
        raise Exception('min must be less than 10')
except Exception:
    print('Моя ошибка')
    raise

# > Моя ошибка
# > Traceback (most recent call last):
# >   File "test.py", line 5, in <module>
# >     raise Exception('min must be less than 10')
# > Exception: min must be less than 10


"""                            Как пропустить ошибку
                            
      Иногда ошибку обрабатывать не нужно. В этом случае ее можно пропустить с помощью pass"""

try:
    a = 7 / 0
except ZeroDivisionError:
    pass


                        """20 типов встроенных исключений в Python"""



# Иерархия классов для встроенных исключений в Python выглядит так:
#
# BaseException
#     SystemExit
#     KeyboardInterrupt
#     GeneratorExit
#     Exception
#         ArithmeticError
#         AssertionError
#         ...
#         ...
#         ...
#         ValueError
#         Warning
"""# Все исключения в Python наследуются от базового BaseException:"""
#
SystemExit           # — системное исключение, вызываемое функцией sys.exit() во время выхода из приложения;
KeyboardInterrupt   #— возникает при завершении программы пользователем (чаще всего при нажатии клавиш Ctrl+C);
GeneratorExit       # — вызывается методом close объекта generator;
Exception             # — исключения, которые можно и нужно обрабатывать (предыдущие были системными и их
                       # трогать не рекомендуется).

"""# От Exception наследуются:"""

# 1
StopIteration               #  — вызывается функцией next в том случае если в итераторе закончились элементы;
# 2
ArithmeticError             #  — ошибки, возникающие при вычислении, бывают следующие типы:
    FloatingPointError      #  — ошибки при выполнении вычислений с плавающей точкой (встречаются редко);
    OverflowError           #  — результат вычислений большой для текущего представления
                            # (не появляется при операциях с целыми числами, но может появиться в
                             # некоторых других случаях);
    ZeroDivisionError       #  — возникает при попытке деления на ноль.
# 3
AssertionError              #  — выражение, используемое в функции assert неверно;
# 4
AttributeError              #  — у объекта отсутствует нужный атрибут;
# 5
BufferError                 #  — операция, для выполнения которой требуется буфер, не выполнена;
# 6
EOFError                    #  — ошибка чтения из файла;
# 7
ImportError                 #  — ошибка импортирования модуля;
# 8
LookupError                 #  — неверный индекс, делится на два типа:
    IndexError              #  — индекс выходит за пределы диапазона элементов;
    KeyError                #  — индекс отсутствует (для словарей, множеств и подобных объектов);
# 9
MemoryError                 #  — память переполнена;
# 10
NameError                   #  — отсутствует переменная с данным именем;
# 11
OSError                     #  — исключения, генерируемые операционной системой:
    ChildProcessError       #  — ошибки, связанные с выполнением дочернего процесса;
    ConnectionError         #  — исключения связанные с подключениями
                            # (BrokenPipeError, ConnectionResetError,
                            # ConnectionRefusedError, ConnectionAbortedError);
    FileExistsError         #  — возникает при попытке создания уже существующего файла или директории;
    FileNotFoundError       #  — генерируется при попытке обращения к несуществующему файлу;
    InterruptedError        #  — возникает в том случае если системный вызов был прерван внешним сигналом;
    IsADirectoryError       #  — программа обращается к файлу, а это директория;
    NotADirectoryError      #  — приложение обращается к директории, а это файл;
    PermissionError         #  — прав доступа недостаточно для выполнения операции;
    ProcessLookupError      #  — процесс, к которому обращается приложение не запущен или отсутствует;
    TimeoutError            #  — время ожидания истекло;
# 12
ReferenceError              #  — попытка доступа к объекту с помощью слабой ссылки, когда объект не существует;
# 13
RuntimeError                #  — генерируется в случае, когда исключение не может быть классифицировано или не подпадает под любую другую категорию;
# 14
NotImplementedError         #  — абстрактные методы класса нуждаются в переопределении;
# 15
SyntaxError                 #  — ошибка синтаксиса;
# 16
SystemError                 #  — сигнализирует о внутренне ошибке;
# 17
TypeError                   #  — операция не может быть выполнена с переменной этого типа;
# 18
ValueError                  #  — возникает когда в функцию передается объект правильного типа,
                            # но имеющий некорректное значение;
# 19
UnicodeError                #  — исключение связанное с кодирование текста в unicode, бывает трех видов:
    UnicodeEncodeError      #  — ошибка кодирования;
    UnicodeDecodeError      #  — ошибка декодирования;
    UnicodeTranslateError   #  — ошибка перевода unicode.
# 20
Warning                     #  — предупреждение, некритическая ошибка.





    """Посмотреть всю цепочку наследования конкретного типа исключения можно с помощью модуля inspect:"""


import inspect

print(inspect.getmro(TimeoutError))

# > (<class 'TimeoutError'>, <class 'OSError'>, <class 'Exception'>, <class 'BaseException'>



"""                                Как создать свой тип Exception
                                
            В Python можно создавать свои исключения. При этом есть одно обязательное условие: 
            они должны быть потомками класса Exception:"""

class MyError(Exception):
    def __init__(self, text):
        self.txt = text


try:
    raise MyError('Моя ошибка')
except MyError as er:
    print(er)

#----------> Моя ошибка
# С помощью # try/except контролируются и обрабатываются ошибки в приложении.
# Это особенно актуально для критически важных частей программы, где любые "падения" недопустимы
# (или могут привести к негативным последствиям). Например, если программа работает как "демон",
# падение приведет к полной остановке её работы. Или, например, при временном сбое соединения с
# базой данных, программа также прервёт своё выполнение (хотя можно было отловить ошибку и
# попробовать соединиться в БД заново).
#
# Вместе с try/except можно использовать дополнительные блоки. Если использовать все блоки,
# то код будет выглядеть так:

try:
    #  попробуем что-то сделать
except (ZeroDivisionError, ValueError) as e:
    #  обрабатываем исключения типа ZeroDivisionError или ValueError
except Exception as e:
    #  исключение не ZeroDivisionError и не ValueError
    #  поэтому обрабатываем исключение общего типа (унаследованное от Exception)
    #  сюда не сходят исключения типа GeneratorExit, KeyboardInterrupt, SystemExit
else:
    #  этот блок выполняется, если нет исключений
    #  если в этом блоке сделать return, он не будет вызван, пока не выполнился блок finally
finally:
    #  этот блок выполняется всегда, даже если нет исключений else будет проигнорирован
    #  если в этом блоке сделать return, то return в блоке
